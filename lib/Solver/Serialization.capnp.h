// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: Serialization.capnp

#ifndef CAPNP_INCLUDED_d90b4ccaa01ea2f1_
#define CAPNP_INCLUDED_d90b4ccaa01ea2f1_

#include <capnp/generated-header-support.h>

#if CAPNP_VERSION != 5001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(f4f540d34e711894);
CAPNP_DECLARE_SCHEMA(a513790369fcdfc5);
CAPNP_DECLARE_SCHEMA(d7eece1599ab8da9);
CAPNP_DECLARE_SCHEMA(d8176e93319b2a9e);
CAPNP_DECLARE_SCHEMA(8b0ad9001806a23d);
CAPNP_DECLARE_SCHEMA(885e1540885aacea);
enum class Kind_885e1540885aacea: uint16_t {
  CONSTANT,
  NOT_OPTIMIZED,
  READ,
  SELECT,
  CONCAT,
  EXTRACT,
  Z_EXT,
  S_EXT,
  ADD,
  SUB,
  MUL,
  U_DIV,
  S_DIV,
  U_REM,
  S_REM,
  NOT,
  AND,
  OR,
  XOR,
  SHL,
  L_SHR,
  A_SHR,
  EQ,
  NE,
  ULT,
  ULE,
  UGT,
  UGE,
  SLT,
  SLE,
  SGT,
  SGE,
  UNKNOWN,
};
CAPNP_DECLARE_ENUM(Kind, 885e1540885aacea);
CAPNP_DECLARE_SCHEMA(dc90c0e6f77519e1);
CAPNP_DECLARE_SCHEMA(883f42a340e41be8);
CAPNP_DECLARE_SCHEMA(9f0a9339dcd803b5);
CAPNP_DECLARE_SCHEMA(e86e6e048947777d);
CAPNP_DECLARE_SCHEMA(d00e3263b37e36ef);
CAPNP_DECLARE_SCHEMA(954e9db67568177d);
CAPNP_DECLARE_SCHEMA(9ae419cc99d46bec);

}  // namespace schemas
}  // namespace capnp

namespace klee {
namespace serialization {

struct Query {
  Query() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    SAT_UNSAT,
    COUNTER_EX_ARRAY_IDS,
  };
  struct Data;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f4f540d34e711894, 1, 5)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Query::Data {
  Data() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a513790369fcdfc5, 1, 5)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Reply {
  Reply() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    UNSOLVABLE,
    SAT,
    UNSAT,
  };
  struct Sat;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d7eece1599ab8da9, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Reply::Sat {
  Sat() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    NO_ASSIGNMENT,
    ASSIGNMENTS,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d8176e93319b2a9e, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Expr {
  Expr() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    CONSTANT_EXPR,
    NON_CONSTANT_EXPR,
  };
  typedef ::capnp::schemas::Kind_885e1540885aacea Kind;

  struct ConstantExpr;
  struct NonConstantExpr;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8b0ad9001806a23d, 3, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Expr::ConstantExpr {
  ConstantExpr() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    WORD,
    WORDS,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dc90c0e6f77519e1, 3, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Expr::NonConstantExpr {
  NonConstantExpr() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    OTHER_NON_CONST,
    READ_EXPR,
    EXTRACT_EXPR,
  };
  struct ReadExpr;
  struct ExtractExpr;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(883f42a340e41be8, 3, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Expr::NonConstantExpr::ReadExpr {
  ReadExpr() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9f0a9339dcd803b5, 3, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Expr::NonConstantExpr::ExtractExpr {
  ExtractExpr() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e86e6e048947777d, 3, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Array {
  Array() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    SYMBOLIC,
    CONSTANT_IDS,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d00e3263b37e36ef, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct UpdateList {
  UpdateList() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(954e9db67568177d, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct UpdateNode {
  UpdateNode() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9ae419cc99d46bec, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Query::Reader {
public:
  typedef Query Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool hasConstraints() const;
  inline  ::capnp::List< ::uint32_t>::Reader getConstraints() const;

  inline  ::uint32_t getExpression() const;

  inline bool isSatUnsat() const;
  inline  ::capnp::Void getSatUnsat() const;

  inline bool isCounterExArrayIds() const;
  inline bool hasCounterExArrayIds() const;
  inline  ::capnp::List< ::uint32_t>::Reader getCounterExArrayIds() const;

  inline Data::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Query::Builder {
public:
  typedef Query Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool hasConstraints();
  inline  ::capnp::List< ::uint32_t>::Builder getConstraints();
  inline void setConstraints( ::capnp::List< ::uint32_t>::Reader value);
  inline void setConstraints(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t>::Builder initConstraints(unsigned int size);
  inline void adoptConstraints(::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> disownConstraints();

  inline  ::uint32_t getExpression();
  inline void setExpression( ::uint32_t value);

  inline bool isSatUnsat();
  inline  ::capnp::Void getSatUnsat();
  inline void setSatUnsat( ::capnp::Void value = ::capnp::VOID);

  inline bool isCounterExArrayIds();
  inline bool hasCounterExArrayIds();
  inline  ::capnp::List< ::uint32_t>::Builder getCounterExArrayIds();
  inline void setCounterExArrayIds( ::capnp::List< ::uint32_t>::Reader value);
  inline void setCounterExArrayIds(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t>::Builder initCounterExArrayIds(unsigned int size);
  inline void adoptCounterExArrayIds(::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> disownCounterExArrayIds();

  inline Data::Builder getData();
  inline Data::Builder initData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Query::Pipeline {
public:
  typedef Query Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline Data::Pipeline getData();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Query::Data::Reader {
public:
  typedef Data Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasExprList() const;
  inline  ::capnp::List< ::klee::serialization::Expr>::Reader getExprList() const;

  inline bool hasArrayList() const;
  inline  ::capnp::List< ::klee::serialization::Array>::Reader getArrayList() const;

  inline bool hasUpdateNodeList() const;
  inline  ::capnp::List< ::klee::serialization::UpdateNode>::Reader getUpdateNodeList() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Query::Data::Builder {
public:
  typedef Data Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasExprList();
  inline  ::capnp::List< ::klee::serialization::Expr>::Builder getExprList();
  inline void setExprList( ::capnp::List< ::klee::serialization::Expr>::Reader value);
  inline  ::capnp::List< ::klee::serialization::Expr>::Builder initExprList(unsigned int size);
  inline void adoptExprList(::capnp::Orphan< ::capnp::List< ::klee::serialization::Expr>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::klee::serialization::Expr>> disownExprList();

  inline bool hasArrayList();
  inline  ::capnp::List< ::klee::serialization::Array>::Builder getArrayList();
  inline void setArrayList( ::capnp::List< ::klee::serialization::Array>::Reader value);
  inline  ::capnp::List< ::klee::serialization::Array>::Builder initArrayList(unsigned int size);
  inline void adoptArrayList(::capnp::Orphan< ::capnp::List< ::klee::serialization::Array>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::klee::serialization::Array>> disownArrayList();

  inline bool hasUpdateNodeList();
  inline  ::capnp::List< ::klee::serialization::UpdateNode>::Builder getUpdateNodeList();
  inline void setUpdateNodeList( ::capnp::List< ::klee::serialization::UpdateNode>::Reader value);
  inline  ::capnp::List< ::klee::serialization::UpdateNode>::Builder initUpdateNodeList(unsigned int size);
  inline void adoptUpdateNodeList(::capnp::Orphan< ::capnp::List< ::klee::serialization::UpdateNode>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::klee::serialization::UpdateNode>> disownUpdateNodeList();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Query::Data::Pipeline {
public:
  typedef Data Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Reply::Reader {
public:
  typedef Reply Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isUnsolvable() const;
  inline  ::capnp::Void getUnsolvable() const;

  inline bool isSat() const;
  inline Sat::Reader getSat() const;

  inline bool isUnsat() const;
  inline  ::capnp::Void getUnsat() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Reply::Builder {
public:
  typedef Reply Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isUnsolvable();
  inline  ::capnp::Void getUnsolvable();
  inline void setUnsolvable( ::capnp::Void value = ::capnp::VOID);

  inline bool isSat();
  inline Sat::Builder getSat();
  inline Sat::Builder initSat();

  inline bool isUnsat();
  inline  ::capnp::Void getUnsat();
  inline void setUnsat( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Reply::Pipeline {
public:
  typedef Reply Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Reply::Sat::Reader {
public:
  typedef Sat Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isNoAssignment() const;
  inline  ::capnp::Void getNoAssignment() const;

  inline bool isAssignments() const;
  inline bool hasAssignments() const;
  inline  ::capnp::List< ::capnp::List< ::uint8_t>>::Reader getAssignments() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Reply::Sat::Builder {
public:
  typedef Sat Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isNoAssignment();
  inline  ::capnp::Void getNoAssignment();
  inline void setNoAssignment( ::capnp::Void value = ::capnp::VOID);

  inline bool isAssignments();
  inline bool hasAssignments();
  inline  ::capnp::List< ::capnp::List< ::uint8_t>>::Builder getAssignments();
  inline void setAssignments( ::capnp::List< ::capnp::List< ::uint8_t>>::Reader value);
  inline void setAssignments(::kj::ArrayPtr<const  ::capnp::List< ::uint8_t>::Reader> value);
  inline  ::capnp::List< ::capnp::List< ::uint8_t>>::Builder initAssignments(unsigned int size);
  inline void adoptAssignments(::capnp::Orphan< ::capnp::List< ::capnp::List< ::uint8_t>>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::uint8_t>>> disownAssignments();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Reply::Sat::Pipeline {
public:
  typedef Sat Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Expr::Reader {
public:
  typedef Expr Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline  ::klee::serialization::Expr::Kind getKind() const;

  inline  ::uint32_t getWidth() const;

  inline bool isConstantExpr() const;
  inline ConstantExpr::Reader getConstantExpr() const;

  inline bool isNonConstantExpr() const;
  inline NonConstantExpr::Reader getNonConstantExpr() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Expr::Builder {
public:
  typedef Expr Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline  ::klee::serialization::Expr::Kind getKind();
  inline void setKind( ::klee::serialization::Expr::Kind value);

  inline  ::uint32_t getWidth();
  inline void setWidth( ::uint32_t value);

  inline bool isConstantExpr();
  inline ConstantExpr::Builder getConstantExpr();
  inline ConstantExpr::Builder initConstantExpr();

  inline bool isNonConstantExpr();
  inline NonConstantExpr::Builder getNonConstantExpr();
  inline NonConstantExpr::Builder initNonConstantExpr();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Expr::Pipeline {
public:
  typedef Expr Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Expr::ConstantExpr::Reader {
public:
  typedef ConstantExpr Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isWord() const;
  inline  ::uint64_t getWord() const;

  inline bool isWords() const;
  inline bool hasWords() const;
  inline  ::capnp::List< ::uint64_t>::Reader getWords() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Expr::ConstantExpr::Builder {
public:
  typedef ConstantExpr Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isWord();
  inline  ::uint64_t getWord();
  inline void setWord( ::uint64_t value);

  inline bool isWords();
  inline bool hasWords();
  inline  ::capnp::List< ::uint64_t>::Builder getWords();
  inline void setWords( ::capnp::List< ::uint64_t>::Reader value);
  inline void setWords(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t>::Builder initWords(unsigned int size);
  inline void adoptWords(::capnp::Orphan< ::capnp::List< ::uint64_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t>> disownWords();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Expr::ConstantExpr::Pipeline {
public:
  typedef ConstantExpr Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Expr::NonConstantExpr::Reader {
public:
  typedef NonConstantExpr Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool hasKidIds() const;
  inline  ::capnp::List< ::uint32_t>::Reader getKidIds() const;

  inline bool isOtherNonConst() const;
  inline  ::capnp::Void getOtherNonConst() const;

  inline bool isReadExpr() const;
  inline ReadExpr::Reader getReadExpr() const;

  inline bool isExtractExpr() const;
  inline ExtractExpr::Reader getExtractExpr() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Expr::NonConstantExpr::Builder {
public:
  typedef NonConstantExpr Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool hasKidIds();
  inline  ::capnp::List< ::uint32_t>::Builder getKidIds();
  inline void setKidIds( ::capnp::List< ::uint32_t>::Reader value);
  inline void setKidIds(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t>::Builder initKidIds(unsigned int size);
  inline void adoptKidIds(::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> disownKidIds();

  inline bool isOtherNonConst();
  inline  ::capnp::Void getOtherNonConst();
  inline void setOtherNonConst( ::capnp::Void value = ::capnp::VOID);

  inline bool isReadExpr();
  inline ReadExpr::Builder getReadExpr();
  inline ReadExpr::Builder initReadExpr();

  inline bool isExtractExpr();
  inline ExtractExpr::Builder getExtractExpr();
  inline ExtractExpr::Builder initExtractExpr();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Expr::NonConstantExpr::Pipeline {
public:
  typedef NonConstantExpr Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Expr::NonConstantExpr::ReadExpr::Reader {
public:
  typedef ReadExpr Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasUpdateList() const;
  inline  ::klee::serialization::UpdateList::Reader getUpdateList() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Expr::NonConstantExpr::ReadExpr::Builder {
public:
  typedef ReadExpr Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasUpdateList();
  inline  ::klee::serialization::UpdateList::Builder getUpdateList();
  inline void setUpdateList( ::klee::serialization::UpdateList::Reader value);
  inline  ::klee::serialization::UpdateList::Builder initUpdateList();
  inline void adoptUpdateList(::capnp::Orphan< ::klee::serialization::UpdateList>&& value);
  inline ::capnp::Orphan< ::klee::serialization::UpdateList> disownUpdateList();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Expr::NonConstantExpr::ReadExpr::Pipeline {
public:
  typedef ReadExpr Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::klee::serialization::UpdateList::Pipeline getUpdateList();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Expr::NonConstantExpr::ExtractExpr::Reader {
public:
  typedef ExtractExpr Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getOffset() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Expr::NonConstantExpr::ExtractExpr::Builder {
public:
  typedef ExtractExpr Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getOffset();
  inline void setOffset( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Expr::NonConstantExpr::ExtractExpr::Pipeline {
public:
  typedef ExtractExpr Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Array::Reader {
public:
  typedef Array Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline  ::uint32_t getSize() const;

  inline  ::uint32_t getDomain() const;

  inline  ::uint32_t getRange() const;

  inline bool isSymbolic() const;
  inline  ::capnp::Void getSymbolic() const;

  inline bool isConstantIds() const;
  inline bool hasConstantIds() const;
  inline  ::capnp::List< ::uint32_t>::Reader getConstantIds() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Array::Builder {
public:
  typedef Array Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline  ::uint32_t getSize();
  inline void setSize( ::uint32_t value);

  inline  ::uint32_t getDomain();
  inline void setDomain( ::uint32_t value);

  inline  ::uint32_t getRange();
  inline void setRange( ::uint32_t value);

  inline bool isSymbolic();
  inline  ::capnp::Void getSymbolic();
  inline void setSymbolic( ::capnp::Void value = ::capnp::VOID);

  inline bool isConstantIds();
  inline bool hasConstantIds();
  inline  ::capnp::List< ::uint32_t>::Builder getConstantIds();
  inline void setConstantIds( ::capnp::List< ::uint32_t>::Reader value);
  inline void setConstantIds(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t>::Builder initConstantIds(unsigned int size);
  inline void adoptConstantIds(::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> disownConstantIds();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Array::Pipeline {
public:
  typedef Array Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class UpdateList::Reader {
public:
  typedef UpdateList Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getArray() const;

  inline  ::uint32_t getHeadNodeId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UpdateList::Builder {
public:
  typedef UpdateList Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getArray();
  inline void setArray( ::uint32_t value);

  inline  ::uint32_t getHeadNodeId();
  inline void setHeadNodeId( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UpdateList::Pipeline {
public:
  typedef UpdateList Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class UpdateNode::Reader {
public:
  typedef UpdateNode Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getSize() const;

  inline  ::uint32_t getNextNodeId() const;

  inline  ::uint32_t getIndexExprId() const;

  inline  ::uint32_t getValueExprId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UpdateNode::Builder {
public:
  typedef UpdateNode Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getSize();
  inline void setSize( ::uint32_t value);

  inline  ::uint32_t getNextNodeId();
  inline void setNextNodeId( ::uint32_t value);

  inline  ::uint32_t getIndexExprId();
  inline void setIndexExprId( ::uint32_t value);

  inline  ::uint32_t getValueExprId();
  inline void setValueExprId( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UpdateNode::Pipeline {
public:
  typedef UpdateNode Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline Query::Which Query::Reader::which() const {
  return _reader.getDataField<Which>(2 * ::capnp::ELEMENTS);
}
inline Query::Which Query::Builder::which() {
  return _builder.getDataField<Which>(2 * ::capnp::ELEMENTS);
}

inline bool Query::Reader::hasConstraints() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Query::Builder::hasConstraints() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t>::Reader Query::Reader::getConstraints() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t>::Builder Query::Builder::getConstraints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Query::Builder::setConstraints( ::capnp::List< ::uint32_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline void Query::Builder::setConstraints(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t>::Builder Query::Builder::initConstraints(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void Query::Builder::adoptConstraints(
    ::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> Query::Builder::disownConstraints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline  ::uint32_t Query::Reader::getExpression() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Query::Builder::getExpression() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Query::Builder::setExpression( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool Query::Reader::isSatUnsat() const {
  return which() == Query::SAT_UNSAT;
}
inline bool Query::Builder::isSatUnsat() {
  return which() == Query::SAT_UNSAT;
}
inline  ::capnp::Void Query::Reader::getSatUnsat() const {
  KJ_IREQUIRE(which() == Query::SAT_UNSAT,
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Query::Builder::getSatUnsat() {
  KJ_IREQUIRE(which() == Query::SAT_UNSAT,
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}
inline void Query::Builder::setSatUnsat( ::capnp::Void value) {
  _builder.setDataField<Query::Which>(
      2 * ::capnp::ELEMENTS, Query::SAT_UNSAT);
  _builder.setDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool Query::Reader::isCounterExArrayIds() const {
  return which() == Query::COUNTER_EX_ARRAY_IDS;
}
inline bool Query::Builder::isCounterExArrayIds() {
  return which() == Query::COUNTER_EX_ARRAY_IDS;
}
inline bool Query::Reader::hasCounterExArrayIds() const {
  if (which() != Query::COUNTER_EX_ARRAY_IDS) return false;
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool Query::Builder::hasCounterExArrayIds() {
  if (which() != Query::COUNTER_EX_ARRAY_IDS) return false;
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t>::Reader Query::Reader::getCounterExArrayIds() const {
  KJ_IREQUIRE(which() == Query::COUNTER_EX_ARRAY_IDS,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t>::Builder Query::Builder::getCounterExArrayIds() {
  KJ_IREQUIRE(which() == Query::COUNTER_EX_ARRAY_IDS,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void Query::Builder::setCounterExArrayIds( ::capnp::List< ::uint32_t>::Reader value) {
  _builder.setDataField<Query::Which>(
      2 * ::capnp::ELEMENTS, Query::COUNTER_EX_ARRAY_IDS);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline void Query::Builder::setCounterExArrayIds(::kj::ArrayPtr<const  ::uint32_t> value) {
  _builder.setDataField<Query::Which>(
      2 * ::capnp::ELEMENTS, Query::COUNTER_EX_ARRAY_IDS);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t>::Builder Query::Builder::initCounterExArrayIds(unsigned int size) {
  _builder.setDataField<Query::Which>(
      2 * ::capnp::ELEMENTS, Query::COUNTER_EX_ARRAY_IDS);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void Query::Builder::adoptCounterExArrayIds(
    ::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value) {
  _builder.setDataField<Query::Which>(
      2 * ::capnp::ELEMENTS, Query::COUNTER_EX_ARRAY_IDS);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> Query::Builder::disownCounterExArrayIds() {
  KJ_IREQUIRE(which() == Query::COUNTER_EX_ARRAY_IDS,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline Query::Data::Reader Query::Reader::getData() const {
  return Query::Data::Reader(_reader);
}
inline Query::Data::Builder Query::Builder::getData() {
  return Query::Data::Builder(_builder);
}
#if !CAPNP_LITE
inline Query::Data::Pipeline Query::Pipeline::getData() {
  return Query::Data::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline Query::Data::Builder Query::Builder::initData() {
  _builder.getPointerField(2 * ::capnp::POINTERS).clear();
  _builder.getPointerField(3 * ::capnp::POINTERS).clear();
  _builder.getPointerField(4 * ::capnp::POINTERS).clear();
  return Query::Data::Builder(_builder);
}
inline bool Query::Data::Reader::hasExprList() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool Query::Data::Builder::hasExprList() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::klee::serialization::Expr>::Reader Query::Data::Reader::getExprList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::klee::serialization::Expr>>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::klee::serialization::Expr>::Builder Query::Data::Builder::getExprList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::klee::serialization::Expr>>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void Query::Data::Builder::setExprList( ::capnp::List< ::klee::serialization::Expr>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::klee::serialization::Expr>>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::klee::serialization::Expr>::Builder Query::Data::Builder::initExprList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::klee::serialization::Expr>>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS), size);
}
inline void Query::Data::Builder::adoptExprList(
    ::capnp::Orphan< ::capnp::List< ::klee::serialization::Expr>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::klee::serialization::Expr>>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::klee::serialization::Expr>> Query::Data::Builder::disownExprList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::klee::serialization::Expr>>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline bool Query::Data::Reader::hasArrayList() const {
  return !_reader.getPointerField(3 * ::capnp::POINTERS).isNull();
}
inline bool Query::Data::Builder::hasArrayList() {
  return !_builder.getPointerField(3 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::klee::serialization::Array>::Reader Query::Data::Reader::getArrayList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::klee::serialization::Array>>::get(
      _reader.getPointerField(3 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::klee::serialization::Array>::Builder Query::Data::Builder::getArrayList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::klee::serialization::Array>>::get(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}
inline void Query::Data::Builder::setArrayList( ::capnp::List< ::klee::serialization::Array>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::klee::serialization::Array>>::set(
      _builder.getPointerField(3 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::klee::serialization::Array>::Builder Query::Data::Builder::initArrayList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::klee::serialization::Array>>::init(
      _builder.getPointerField(3 * ::capnp::POINTERS), size);
}
inline void Query::Data::Builder::adoptArrayList(
    ::capnp::Orphan< ::capnp::List< ::klee::serialization::Array>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::klee::serialization::Array>>::adopt(
      _builder.getPointerField(3 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::klee::serialization::Array>> Query::Data::Builder::disownArrayList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::klee::serialization::Array>>::disown(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}

inline bool Query::Data::Reader::hasUpdateNodeList() const {
  return !_reader.getPointerField(4 * ::capnp::POINTERS).isNull();
}
inline bool Query::Data::Builder::hasUpdateNodeList() {
  return !_builder.getPointerField(4 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::klee::serialization::UpdateNode>::Reader Query::Data::Reader::getUpdateNodeList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::klee::serialization::UpdateNode>>::get(
      _reader.getPointerField(4 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::klee::serialization::UpdateNode>::Builder Query::Data::Builder::getUpdateNodeList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::klee::serialization::UpdateNode>>::get(
      _builder.getPointerField(4 * ::capnp::POINTERS));
}
inline void Query::Data::Builder::setUpdateNodeList( ::capnp::List< ::klee::serialization::UpdateNode>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::klee::serialization::UpdateNode>>::set(
      _builder.getPointerField(4 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::klee::serialization::UpdateNode>::Builder Query::Data::Builder::initUpdateNodeList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::klee::serialization::UpdateNode>>::init(
      _builder.getPointerField(4 * ::capnp::POINTERS), size);
}
inline void Query::Data::Builder::adoptUpdateNodeList(
    ::capnp::Orphan< ::capnp::List< ::klee::serialization::UpdateNode>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::klee::serialization::UpdateNode>>::adopt(
      _builder.getPointerField(4 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::klee::serialization::UpdateNode>> Query::Data::Builder::disownUpdateNodeList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::klee::serialization::UpdateNode>>::disown(
      _builder.getPointerField(4 * ::capnp::POINTERS));
}

inline Reply::Which Reply::Reader::which() const {
  return _reader.getDataField<Which>(0 * ::capnp::ELEMENTS);
}
inline Reply::Which Reply::Builder::which() {
  return _builder.getDataField<Which>(0 * ::capnp::ELEMENTS);
}

inline bool Reply::Reader::isUnsolvable() const {
  return which() == Reply::UNSOLVABLE;
}
inline bool Reply::Builder::isUnsolvable() {
  return which() == Reply::UNSOLVABLE;
}
inline  ::capnp::Void Reply::Reader::getUnsolvable() const {
  KJ_IREQUIRE(which() == Reply::UNSOLVABLE,
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Reply::Builder::getUnsolvable() {
  KJ_IREQUIRE(which() == Reply::UNSOLVABLE,
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}
inline void Reply::Builder::setUnsolvable( ::capnp::Void value) {
  _builder.setDataField<Reply::Which>(
      0 * ::capnp::ELEMENTS, Reply::UNSOLVABLE);
  _builder.setDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool Reply::Reader::isSat() const {
  return which() == Reply::SAT;
}
inline bool Reply::Builder::isSat() {
  return which() == Reply::SAT;
}
inline Reply::Sat::Reader Reply::Reader::getSat() const {
  KJ_IREQUIRE(which() == Reply::SAT,
              "Must check which() before get()ing a union member.");
  return Reply::Sat::Reader(_reader);
}
inline Reply::Sat::Builder Reply::Builder::getSat() {
  KJ_IREQUIRE(which() == Reply::SAT,
              "Must check which() before get()ing a union member.");
  return Reply::Sat::Builder(_builder);
}
inline Reply::Sat::Builder Reply::Builder::initSat() {
  _builder.setDataField<Reply::Which>(
      0 * ::capnp::ELEMENTS, Reply::SAT);
  _builder.setDataField< ::uint16_t>(1 * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(0 * ::capnp::POINTERS).clear();
  return Reply::Sat::Builder(_builder);
}
inline bool Reply::Reader::isUnsat() const {
  return which() == Reply::UNSAT;
}
inline bool Reply::Builder::isUnsat() {
  return which() == Reply::UNSAT;
}
inline  ::capnp::Void Reply::Reader::getUnsat() const {
  KJ_IREQUIRE(which() == Reply::UNSAT,
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Reply::Builder::getUnsat() {
  KJ_IREQUIRE(which() == Reply::UNSAT,
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}
inline void Reply::Builder::setUnsat( ::capnp::Void value) {
  _builder.setDataField<Reply::Which>(
      0 * ::capnp::ELEMENTS, Reply::UNSAT);
  _builder.setDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS, value);
}

inline Reply::Sat::Which Reply::Sat::Reader::which() const {
  return _reader.getDataField<Which>(1 * ::capnp::ELEMENTS);
}
inline Reply::Sat::Which Reply::Sat::Builder::which() {
  return _builder.getDataField<Which>(1 * ::capnp::ELEMENTS);
}

inline bool Reply::Sat::Reader::isNoAssignment() const {
  return which() == Reply::Sat::NO_ASSIGNMENT;
}
inline bool Reply::Sat::Builder::isNoAssignment() {
  return which() == Reply::Sat::NO_ASSIGNMENT;
}
inline  ::capnp::Void Reply::Sat::Reader::getNoAssignment() const {
  KJ_IREQUIRE(which() == Reply::Sat::NO_ASSIGNMENT,
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Reply::Sat::Builder::getNoAssignment() {
  KJ_IREQUIRE(which() == Reply::Sat::NO_ASSIGNMENT,
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}
inline void Reply::Sat::Builder::setNoAssignment( ::capnp::Void value) {
  _builder.setDataField<Reply::Sat::Which>(
      1 * ::capnp::ELEMENTS, Reply::Sat::NO_ASSIGNMENT);
  _builder.setDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool Reply::Sat::Reader::isAssignments() const {
  return which() == Reply::Sat::ASSIGNMENTS;
}
inline bool Reply::Sat::Builder::isAssignments() {
  return which() == Reply::Sat::ASSIGNMENTS;
}
inline bool Reply::Sat::Reader::hasAssignments() const {
  if (which() != Reply::Sat::ASSIGNMENTS) return false;
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Reply::Sat::Builder::hasAssignments() {
  if (which() != Reply::Sat::ASSIGNMENTS) return false;
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::List< ::uint8_t>>::Reader Reply::Sat::Reader::getAssignments() const {
  KJ_IREQUIRE(which() == Reply::Sat::ASSIGNMENTS,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::uint8_t>>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::List< ::uint8_t>>::Builder Reply::Sat::Builder::getAssignments() {
  KJ_IREQUIRE(which() == Reply::Sat::ASSIGNMENTS,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::uint8_t>>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Reply::Sat::Builder::setAssignments( ::capnp::List< ::capnp::List< ::uint8_t>>::Reader value) {
  _builder.setDataField<Reply::Sat::Which>(
      1 * ::capnp::ELEMENTS, Reply::Sat::ASSIGNMENTS);
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::uint8_t>>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline void Reply::Sat::Builder::setAssignments(::kj::ArrayPtr<const  ::capnp::List< ::uint8_t>::Reader> value) {
  _builder.setDataField<Reply::Sat::Which>(
      1 * ::capnp::ELEMENTS, Reply::Sat::ASSIGNMENTS);
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::uint8_t>>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::List< ::uint8_t>>::Builder Reply::Sat::Builder::initAssignments(unsigned int size) {
  _builder.setDataField<Reply::Sat::Which>(
      1 * ::capnp::ELEMENTS, Reply::Sat::ASSIGNMENTS);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::uint8_t>>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void Reply::Sat::Builder::adoptAssignments(
    ::capnp::Orphan< ::capnp::List< ::capnp::List< ::uint8_t>>>&& value) {
  _builder.setDataField<Reply::Sat::Which>(
      1 * ::capnp::ELEMENTS, Reply::Sat::ASSIGNMENTS);
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::uint8_t>>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::uint8_t>>> Reply::Sat::Builder::disownAssignments() {
  KJ_IREQUIRE(which() == Reply::Sat::ASSIGNMENTS,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::uint8_t>>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline Expr::Which Expr::Reader::which() const {
  return _reader.getDataField<Which>(8 * ::capnp::ELEMENTS);
}
inline Expr::Which Expr::Builder::which() {
  return _builder.getDataField<Which>(8 * ::capnp::ELEMENTS);
}

inline  ::klee::serialization::Expr::Kind Expr::Reader::getKind() const {
  return _reader.getDataField< ::klee::serialization::Expr::Kind>(
      0 * ::capnp::ELEMENTS);
}

inline  ::klee::serialization::Expr::Kind Expr::Builder::getKind() {
  return _builder.getDataField< ::klee::serialization::Expr::Kind>(
      0 * ::capnp::ELEMENTS);
}
inline void Expr::Builder::setKind( ::klee::serialization::Expr::Kind value) {
  _builder.setDataField< ::klee::serialization::Expr::Kind>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Expr::Reader::getWidth() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Expr::Builder::getWidth() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Expr::Builder::setWidth( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline bool Expr::Reader::isConstantExpr() const {
  return which() == Expr::CONSTANT_EXPR;
}
inline bool Expr::Builder::isConstantExpr() {
  return which() == Expr::CONSTANT_EXPR;
}
inline Expr::ConstantExpr::Reader Expr::Reader::getConstantExpr() const {
  KJ_IREQUIRE(which() == Expr::CONSTANT_EXPR,
              "Must check which() before get()ing a union member.");
  return Expr::ConstantExpr::Reader(_reader);
}
inline Expr::ConstantExpr::Builder Expr::Builder::getConstantExpr() {
  KJ_IREQUIRE(which() == Expr::CONSTANT_EXPR,
              "Must check which() before get()ing a union member.");
  return Expr::ConstantExpr::Builder(_builder);
}
inline Expr::ConstantExpr::Builder Expr::Builder::initConstantExpr() {
  _builder.setDataField<Expr::Which>(
      8 * ::capnp::ELEMENTS, Expr::CONSTANT_EXPR);
  _builder.setDataField< ::uint16_t>(1 * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(1 * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(0 * ::capnp::POINTERS).clear();
  return Expr::ConstantExpr::Builder(_builder);
}
inline bool Expr::Reader::isNonConstantExpr() const {
  return which() == Expr::NON_CONSTANT_EXPR;
}
inline bool Expr::Builder::isNonConstantExpr() {
  return which() == Expr::NON_CONSTANT_EXPR;
}
inline Expr::NonConstantExpr::Reader Expr::Reader::getNonConstantExpr() const {
  KJ_IREQUIRE(which() == Expr::NON_CONSTANT_EXPR,
              "Must check which() before get()ing a union member.");
  return Expr::NonConstantExpr::Reader(_reader);
}
inline Expr::NonConstantExpr::Builder Expr::Builder::getNonConstantExpr() {
  KJ_IREQUIRE(which() == Expr::NON_CONSTANT_EXPR,
              "Must check which() before get()ing a union member.");
  return Expr::NonConstantExpr::Builder(_builder);
}
inline Expr::NonConstantExpr::Builder Expr::Builder::initNonConstantExpr() {
  _builder.setDataField<Expr::Which>(
      8 * ::capnp::ELEMENTS, Expr::NON_CONSTANT_EXPR);
  _builder.setDataField< ::uint16_t>(1 * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint32_t>(2 * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(0 * ::capnp::POINTERS).clear();
  _builder.getPointerField(1 * ::capnp::POINTERS).clear();
  return Expr::NonConstantExpr::Builder(_builder);
}
inline Expr::ConstantExpr::Which Expr::ConstantExpr::Reader::which() const {
  return _reader.getDataField<Which>(1 * ::capnp::ELEMENTS);
}
inline Expr::ConstantExpr::Which Expr::ConstantExpr::Builder::which() {
  return _builder.getDataField<Which>(1 * ::capnp::ELEMENTS);
}

inline bool Expr::ConstantExpr::Reader::isWord() const {
  return which() == Expr::ConstantExpr::WORD;
}
inline bool Expr::ConstantExpr::Builder::isWord() {
  return which() == Expr::ConstantExpr::WORD;
}
inline  ::uint64_t Expr::ConstantExpr::Reader::getWord() const {
  KJ_IREQUIRE(which() == Expr::ConstantExpr::WORD,
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint64_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint64_t Expr::ConstantExpr::Builder::getWord() {
  KJ_IREQUIRE(which() == Expr::ConstantExpr::WORD,
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint64_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Expr::ConstantExpr::Builder::setWord( ::uint64_t value) {
  _builder.setDataField<Expr::ConstantExpr::Which>(
      1 * ::capnp::ELEMENTS, Expr::ConstantExpr::WORD);
  _builder.setDataField< ::uint64_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline bool Expr::ConstantExpr::Reader::isWords() const {
  return which() == Expr::ConstantExpr::WORDS;
}
inline bool Expr::ConstantExpr::Builder::isWords() {
  return which() == Expr::ConstantExpr::WORDS;
}
inline bool Expr::ConstantExpr::Reader::hasWords() const {
  if (which() != Expr::ConstantExpr::WORDS) return false;
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Expr::ConstantExpr::Builder::hasWords() {
  if (which() != Expr::ConstantExpr::WORDS) return false;
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t>::Reader Expr::ConstantExpr::Reader::getWords() const {
  KJ_IREQUIRE(which() == Expr::ConstantExpr::WORDS,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t>::Builder Expr::ConstantExpr::Builder::getWords() {
  KJ_IREQUIRE(which() == Expr::ConstantExpr::WORDS,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Expr::ConstantExpr::Builder::setWords( ::capnp::List< ::uint64_t>::Reader value) {
  _builder.setDataField<Expr::ConstantExpr::Which>(
      1 * ::capnp::ELEMENTS, Expr::ConstantExpr::WORDS);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline void Expr::ConstantExpr::Builder::setWords(::kj::ArrayPtr<const  ::uint64_t> value) {
  _builder.setDataField<Expr::ConstantExpr::Which>(
      1 * ::capnp::ELEMENTS, Expr::ConstantExpr::WORDS);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t>::Builder Expr::ConstantExpr::Builder::initWords(unsigned int size) {
  _builder.setDataField<Expr::ConstantExpr::Which>(
      1 * ::capnp::ELEMENTS, Expr::ConstantExpr::WORDS);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void Expr::ConstantExpr::Builder::adoptWords(
    ::capnp::Orphan< ::capnp::List< ::uint64_t>>&& value) {
  _builder.setDataField<Expr::ConstantExpr::Which>(
      1 * ::capnp::ELEMENTS, Expr::ConstantExpr::WORDS);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t>> Expr::ConstantExpr::Builder::disownWords() {
  KJ_IREQUIRE(which() == Expr::ConstantExpr::WORDS,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline Expr::NonConstantExpr::Which Expr::NonConstantExpr::Reader::which() const {
  return _reader.getDataField<Which>(1 * ::capnp::ELEMENTS);
}
inline Expr::NonConstantExpr::Which Expr::NonConstantExpr::Builder::which() {
  return _builder.getDataField<Which>(1 * ::capnp::ELEMENTS);
}

inline bool Expr::NonConstantExpr::Reader::hasKidIds() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Expr::NonConstantExpr::Builder::hasKidIds() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t>::Reader Expr::NonConstantExpr::Reader::getKidIds() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t>::Builder Expr::NonConstantExpr::Builder::getKidIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Expr::NonConstantExpr::Builder::setKidIds( ::capnp::List< ::uint32_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline void Expr::NonConstantExpr::Builder::setKidIds(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t>::Builder Expr::NonConstantExpr::Builder::initKidIds(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void Expr::NonConstantExpr::Builder::adoptKidIds(
    ::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> Expr::NonConstantExpr::Builder::disownKidIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool Expr::NonConstantExpr::Reader::isOtherNonConst() const {
  return which() == Expr::NonConstantExpr::OTHER_NON_CONST;
}
inline bool Expr::NonConstantExpr::Builder::isOtherNonConst() {
  return which() == Expr::NonConstantExpr::OTHER_NON_CONST;
}
inline  ::capnp::Void Expr::NonConstantExpr::Reader::getOtherNonConst() const {
  KJ_IREQUIRE(which() == Expr::NonConstantExpr::OTHER_NON_CONST,
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Expr::NonConstantExpr::Builder::getOtherNonConst() {
  KJ_IREQUIRE(which() == Expr::NonConstantExpr::OTHER_NON_CONST,
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}
inline void Expr::NonConstantExpr::Builder::setOtherNonConst( ::capnp::Void value) {
  _builder.setDataField<Expr::NonConstantExpr::Which>(
      1 * ::capnp::ELEMENTS, Expr::NonConstantExpr::OTHER_NON_CONST);
  _builder.setDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool Expr::NonConstantExpr::Reader::isReadExpr() const {
  return which() == Expr::NonConstantExpr::READ_EXPR;
}
inline bool Expr::NonConstantExpr::Builder::isReadExpr() {
  return which() == Expr::NonConstantExpr::READ_EXPR;
}
inline Expr::NonConstantExpr::ReadExpr::Reader Expr::NonConstantExpr::Reader::getReadExpr() const {
  KJ_IREQUIRE(which() == Expr::NonConstantExpr::READ_EXPR,
              "Must check which() before get()ing a union member.");
  return Expr::NonConstantExpr::ReadExpr::Reader(_reader);
}
inline Expr::NonConstantExpr::ReadExpr::Builder Expr::NonConstantExpr::Builder::getReadExpr() {
  KJ_IREQUIRE(which() == Expr::NonConstantExpr::READ_EXPR,
              "Must check which() before get()ing a union member.");
  return Expr::NonConstantExpr::ReadExpr::Builder(_builder);
}
inline Expr::NonConstantExpr::ReadExpr::Builder Expr::NonConstantExpr::Builder::initReadExpr() {
  _builder.setDataField<Expr::NonConstantExpr::Which>(
      1 * ::capnp::ELEMENTS, Expr::NonConstantExpr::READ_EXPR);
  _builder.getPointerField(1 * ::capnp::POINTERS).clear();
  return Expr::NonConstantExpr::ReadExpr::Builder(_builder);
}
inline bool Expr::NonConstantExpr::Reader::isExtractExpr() const {
  return which() == Expr::NonConstantExpr::EXTRACT_EXPR;
}
inline bool Expr::NonConstantExpr::Builder::isExtractExpr() {
  return which() == Expr::NonConstantExpr::EXTRACT_EXPR;
}
inline Expr::NonConstantExpr::ExtractExpr::Reader Expr::NonConstantExpr::Reader::getExtractExpr() const {
  KJ_IREQUIRE(which() == Expr::NonConstantExpr::EXTRACT_EXPR,
              "Must check which() before get()ing a union member.");
  return Expr::NonConstantExpr::ExtractExpr::Reader(_reader);
}
inline Expr::NonConstantExpr::ExtractExpr::Builder Expr::NonConstantExpr::Builder::getExtractExpr() {
  KJ_IREQUIRE(which() == Expr::NonConstantExpr::EXTRACT_EXPR,
              "Must check which() before get()ing a union member.");
  return Expr::NonConstantExpr::ExtractExpr::Builder(_builder);
}
inline Expr::NonConstantExpr::ExtractExpr::Builder Expr::NonConstantExpr::Builder::initExtractExpr() {
  _builder.setDataField<Expr::NonConstantExpr::Which>(
      1 * ::capnp::ELEMENTS, Expr::NonConstantExpr::EXTRACT_EXPR);
  _builder.setDataField< ::uint32_t>(2 * ::capnp::ELEMENTS, 0);
  return Expr::NonConstantExpr::ExtractExpr::Builder(_builder);
}
inline bool Expr::NonConstantExpr::ReadExpr::Reader::hasUpdateList() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool Expr::NonConstantExpr::ReadExpr::Builder::hasUpdateList() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::klee::serialization::UpdateList::Reader Expr::NonConstantExpr::ReadExpr::Reader::getUpdateList() const {
  return ::capnp::_::PointerHelpers< ::klee::serialization::UpdateList>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::klee::serialization::UpdateList::Builder Expr::NonConstantExpr::ReadExpr::Builder::getUpdateList() {
  return ::capnp::_::PointerHelpers< ::klee::serialization::UpdateList>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::klee::serialization::UpdateList::Pipeline Expr::NonConstantExpr::ReadExpr::Pipeline::getUpdateList() {
  return  ::klee::serialization::UpdateList::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Expr::NonConstantExpr::ReadExpr::Builder::setUpdateList( ::klee::serialization::UpdateList::Reader value) {
  ::capnp::_::PointerHelpers< ::klee::serialization::UpdateList>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::klee::serialization::UpdateList::Builder Expr::NonConstantExpr::ReadExpr::Builder::initUpdateList() {
  return ::capnp::_::PointerHelpers< ::klee::serialization::UpdateList>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void Expr::NonConstantExpr::ReadExpr::Builder::adoptUpdateList(
    ::capnp::Orphan< ::klee::serialization::UpdateList>&& value) {
  ::capnp::_::PointerHelpers< ::klee::serialization::UpdateList>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::klee::serialization::UpdateList> Expr::NonConstantExpr::ReadExpr::Builder::disownUpdateList() {
  return ::capnp::_::PointerHelpers< ::klee::serialization::UpdateList>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline  ::uint32_t Expr::NonConstantExpr::ExtractExpr::Reader::getOffset() const {
  return _reader.getDataField< ::uint32_t>(
      2 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Expr::NonConstantExpr::ExtractExpr::Builder::getOffset() {
  return _builder.getDataField< ::uint32_t>(
      2 * ::capnp::ELEMENTS);
}
inline void Expr::NonConstantExpr::ExtractExpr::Builder::setOffset( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      2 * ::capnp::ELEMENTS, value);
}

inline Array::Which Array::Reader::which() const {
  return _reader.getDataField<Which>(6 * ::capnp::ELEMENTS);
}
inline Array::Which Array::Builder::which() {
  return _builder.getDataField<Which>(6 * ::capnp::ELEMENTS);
}

inline bool Array::Reader::hasName() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Array::Builder::hasName() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Array::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Array::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Array::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Array::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void Array::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Array::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline  ::uint32_t Array::Reader::getSize() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Array::Builder::getSize() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Array::Builder::setSize( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Array::Reader::getDomain() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Array::Builder::getDomain() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Array::Builder::setDomain( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Array::Reader::getRange() const {
  return _reader.getDataField< ::uint32_t>(
      2 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Array::Builder::getRange() {
  return _builder.getDataField< ::uint32_t>(
      2 * ::capnp::ELEMENTS);
}
inline void Array::Builder::setRange( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      2 * ::capnp::ELEMENTS, value);
}

inline bool Array::Reader::isSymbolic() const {
  return which() == Array::SYMBOLIC;
}
inline bool Array::Builder::isSymbolic() {
  return which() == Array::SYMBOLIC;
}
inline  ::capnp::Void Array::Reader::getSymbolic() const {
  KJ_IREQUIRE(which() == Array::SYMBOLIC,
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Array::Builder::getSymbolic() {
  KJ_IREQUIRE(which() == Array::SYMBOLIC,
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS);
}
inline void Array::Builder::setSymbolic( ::capnp::Void value) {
  _builder.setDataField<Array::Which>(
      6 * ::capnp::ELEMENTS, Array::SYMBOLIC);
  _builder.setDataField< ::capnp::Void>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool Array::Reader::isConstantIds() const {
  return which() == Array::CONSTANT_IDS;
}
inline bool Array::Builder::isConstantIds() {
  return which() == Array::CONSTANT_IDS;
}
inline bool Array::Reader::hasConstantIds() const {
  if (which() != Array::CONSTANT_IDS) return false;
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool Array::Builder::hasConstantIds() {
  if (which() != Array::CONSTANT_IDS) return false;
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t>::Reader Array::Reader::getConstantIds() const {
  KJ_IREQUIRE(which() == Array::CONSTANT_IDS,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t>::Builder Array::Builder::getConstantIds() {
  KJ_IREQUIRE(which() == Array::CONSTANT_IDS,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void Array::Builder::setConstantIds( ::capnp::List< ::uint32_t>::Reader value) {
  _builder.setDataField<Array::Which>(
      6 * ::capnp::ELEMENTS, Array::CONSTANT_IDS);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline void Array::Builder::setConstantIds(::kj::ArrayPtr<const  ::uint32_t> value) {
  _builder.setDataField<Array::Which>(
      6 * ::capnp::ELEMENTS, Array::CONSTANT_IDS);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t>::Builder Array::Builder::initConstantIds(unsigned int size) {
  _builder.setDataField<Array::Which>(
      6 * ::capnp::ELEMENTS, Array::CONSTANT_IDS);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void Array::Builder::adoptConstantIds(
    ::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value) {
  _builder.setDataField<Array::Which>(
      6 * ::capnp::ELEMENTS, Array::CONSTANT_IDS);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> Array::Builder::disownConstantIds() {
  KJ_IREQUIRE(which() == Array::CONSTANT_IDS,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline  ::uint32_t UpdateList::Reader::getArray() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t UpdateList::Builder::getArray() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void UpdateList::Builder::setArray( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t UpdateList::Reader::getHeadNodeId() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t UpdateList::Builder::getHeadNodeId() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void UpdateList::Builder::setHeadNodeId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t UpdateNode::Reader::getSize() const {
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t UpdateNode::Builder::getSize() {
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void UpdateNode::Builder::setSize( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t UpdateNode::Reader::getNextNodeId() const {
  return _reader.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint32_t UpdateNode::Builder::getNextNodeId() {
  return _builder.getDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void UpdateNode::Builder::setNextNodeId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t UpdateNode::Reader::getIndexExprId() const {
  return _reader.getDataField< ::uint32_t>(
      2 * ::capnp::ELEMENTS);
}

inline  ::uint32_t UpdateNode::Builder::getIndexExprId() {
  return _builder.getDataField< ::uint32_t>(
      2 * ::capnp::ELEMENTS);
}
inline void UpdateNode::Builder::setIndexExprId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      2 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t UpdateNode::Reader::getValueExprId() const {
  return _reader.getDataField< ::uint32_t>(
      3 * ::capnp::ELEMENTS);
}

inline  ::uint32_t UpdateNode::Builder::getValueExprId() {
  return _builder.getDataField< ::uint32_t>(
      3 * ::capnp::ELEMENTS);
}
inline void UpdateNode::Builder::setValueExprId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      3 * ::capnp::ELEMENTS, value);
}

}  // namespace
}  // namespace

#endif  // CAPNP_INCLUDED_d90b4ccaa01ea2f1_
